---
title: "DSA2101 Group Project: Analysis of Taylor Swift Spotify Data"
output: github_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
library(tidytuesdayR)
library(tidyverse)
library(readr)
library(knitr)
```

## Group members
```{r}
students <- data.frame(
  Group_Members = c("Chua Yong Sheng Joel", "Lim Zeen Kiat", "Robin Ghosh", "Timothy Teo Shao Jun"),
  Matriculation_Number = c("A_", "A0273151M", "A0271671A", "A0272851B")
)

kable(students, col.names = c("Group Members", "Matriculation Number"))
```

## Loading Data
```{r}
# Load the Taylor Swift datasets
tuesdata <- tidytuesdayR::tt_load(2023, week = 42)

taylor_album_songs <- tuesdata$taylor_album_songs
taylor_all_songs <- tuesdata$taylor_all_songs
taylor_albums <- tuesdata$taylor_albums

# Save each dataset to new CSV files
# write.csv(taylor_album_songs, "taylor_album_songs.csv", row.names = FALSE)
# write.csv(taylor_all_songs, "taylor_all_songs.csv", row.names = FALSE)
# write.csv(taylor_albums, "taylor_albums.csv", row.names = FALSE)
```
=======

## 1. Introduction

Taylor Swift's music has had a significant impact on the global pop and country music scenes. 
In this project, we used the Taylor Swift Spotify data sourced from the TidyTuesday repository to analyse the musical and lyrical features of her music. 
This dataset includes detailed audio attributes of her songs which we aim to use in this project. 
By exploring the given data, we aim to discover the patterns that have emerged throughout Taylor Swiftâ€™s career and gain insights into how her music has evolved.

For our project, we aim to answer the following question:
```bash
How do musical and lyrical features evolve across Taylor Swift's albums, and what insights can we gain about the progression of her artistry over time?
```
This analysis will allow us to identify trends in musical characteristics and examine how stylistic changes have corresponded with different stages of her career. 
By doing so, we hope to provide a deeper understanding of how Taylor Swift has redefined her career and connect with a global audience.


## 2. Data Cleaning & Summary
### Summary of relevant statistics
The following table contains a brief description of the variables we have chosen to use for our project:
```{r}
track_attributes <- data.frame(
  Variable = c(
    "album_name", "album_release", "track_name", "danceability", "energy", 
    "loudness", "mode", "speechiness", "acousticness", "instrumentalness", 
    "liveness", "valence", "tempo", "explicit"
  ),
  Class = c(
    "character", "double", "character", "double", "double", "double", "integer",
    "double", "double", "double", "double", "double", "double", "logical"
  ),
  Description = c(
    "Name of the album the track belongs to.",
    "Release date of the album.",
    "Name of the individual track.",
    "Measures how suitable a track is for dancing.",
    "Measures the intensity and activity of a track, with higher values indicating more energetic sounds.",
    "The overall volume of the track, measured in decibels (dB).",
    "This is also a categorical variable. It indicates the modality of the track: 1 for major, 0 for minor.",
    "Measures the presence of spoken words in a track, with higher values indicating more speech-like content.",
    "Represents the likelihood that the track is acoustic, with higher values indicating more acoustic qualities.",
    "Predicts whether a track is instrumental, with higher values suggesting a lack of vocals.",
    "Measures the presence of an audience in the recording, with higher values indicating a stronger likelihood that the track is live",
    "Describes the musical positiveness conveyed, with higher values indicating more cheerful and happy tones.",
    "The speed of the track, measured in beats per minute (BPM).",
    "Indicates whether the track contains explicit content: 1 for explicit, 0 otherwise."
  )
)
kable(track_attributes, col.names = c("Variable", "Class", "Description"), align = "l")
```

### Data cleaning
We'll start off by filtering for the features listed above which we want to keep:
```{r}
taylor_album_songs <- taylor_album_songs %>%
    select(album_name, album_release, track_name, danceability, energy, loudness, mode, speechiness, acousticness, instrumentalness, liveness, valence, tempo, explicit)

taylor_all_songs <- taylor_all_songs %>%
    select(album_name, album_release, track_name, danceability, energy, loudness, mode, speechiness, acousticness, instrumentalness, liveness, valence, tempo, explicit)

taylor_albums <- taylor_albums %>%
    select(!ep)
```

Then, we group the data by their respective albums for aggregating album data:
```{r}
taylor_album_songs <- taylor_album_songs %>%
  group_by(album_name)

taylor_all_songs <- taylor_all_songs %>%
  group_by(album_name)

taylor_albums <- taylor_albums %>%
  group_by(album_name)
```

We will check and remove NA values in the data, which are not needed for our visualisations:
```{r}
taylor_album_songs_na_count <- sapply(taylor_album_songs, function(x) sum(is.na(x)))
print(taylor_album_songs_na_count)

taylor_all_songs_na_count <- sapply(taylor_all_songs, function(x) sum(is.na(x)))
print(taylor_all_songs_na_count)

taylor_albums_na_count <- sapply(taylor_albums, function(x) sum(is.na(x)))
print(taylor_albums_na_count)

taylor_album_songs <- taylor_album_songs %>%
    na.omit()

taylor_all_songs <- taylor_all_songs %>%
    na.omit()

taylor_albums <- taylor_albums %>%
    na.omit()
```

To ensure that the visualisation representations are balanced, we will check the range of the various song features to see whether there is a need to scale the features:
```{r}
# Checking range of values (for all the songs) of numerical variables in taylor_all_songs
ranges_taylor_all_songs <- taylor_all_songs %>%
  ungroup() %>%
  select(liveness:tempo) %>%
  summarise(across(liveness:tempo, ~paste(min(.), "to", max(.))))
glimpse(ranges_taylor_all_songs)

# Checking range of values of numerical variables in taylor_album_songs
ranges_taylor_album_songs <- taylor_album_songs %>%
  select(liveness:tempo) %>%
  summarise(across(liveness:tempo, ~paste(min(.), "to", max(.))))
glimpse(ranges_taylor_album_songs)
```

Loudness is measured in decibels, which has a logarithmic scale. To enable a clearer visual representation, we will first convert the values of loudness to a linear scale, before scaling the values between 0 and 1.
```{r}
# Scaling loudness for taylor_all_songs
taylor_all_songs <- taylor_all_songs %>%
  ungroup() %>%
  mutate(loudness = 10^(loudness/10)) #%>%
  #mutate(normalised_intensity = (intensity - min(intensity)) / (max(intensity) - min(intensity)))
glimpse(taylor_all_songs)

# Scaling loudness for taylor_album_songs
taylor_album_songs <- taylor_album_songs %>%
  mutate(loudness = 10^(loudness/10)) #%>%
  #mutate(normalised_intensity = (intensity - min(intensity)) / (max(intensity) - min(intensity)))
glimpse(taylor_album_songs)
```

Finally, the cleaned data are saved as new files for us to reference later on:
```{r}
write.csv(taylor_album_songs, "CSV files/taylor_album_songs_cleaned.csv", row.names = FALSE)
write.csv(taylor_all_songs, "CSV files/taylor_all_songs_cleaned.csv", row.names = FALSE)
write.csv(taylor_albums, "CSV files/taylor_albums.csv_cleaned", row.names = FALSE)
```


### Data engineering
```{r using-cleaned-datasets}
head(taylor_album_songs)
head(taylor_all_songs)
head(taylor_albums)
```

```{r}
names(taylor_album_songs)==names(taylor_all_songs)
checking_conflicts <- taylor_album_songs %>% anti_join(taylor_all_songs, by=names(taylor_all_songs))
head(checking_conflicts)
```

All the column names match for both tables. A tibble of no elements was generated, thus confirming that all rows are present in either tables. Since we can choose which
table we want, we will use taylor_album_songs.

Next, since we are trying to compare popularity statistics by album, we need to check which albums are present in `taylor_album_songs` and `taylor_albums`.

```{r}
names1 <- taylor_albums %>% select(album_name) %>% unique() %>% arrange(album_name)
names2 <- taylor_album_songs %>% select(album_name) %>% unique() %>% arrange(album_name)

comp_table=left_join(names1, names2, by=c("album_name"))

combined_table = rep(NA,length(comp_table$album_name))

for (i in 1:length(names1$album_name) ){
  if (names1$album_name[i] %in% names2$album_name) {
    combined_table[i] <- comp_table$album_name[i]
  }
}

combined_table = cbind(names1$album_name,combined_table)
knitr::kable(combined_table, col.names = c("Taylor Albums","Taylor Album Songs"), caption="Comparison of album names between the tables")
```

Checking the table generated, Fearless and Red do not appear in Taylor Album Songs, thus they will not be considered for popularity comparison.
Next, we will aggregate statistics for each of the musical attributes by taking their mean. Then, we will combine `taylor_album_songs` and `taylor_albums` to tie the popularity metrics with each common album.

```{r aggregating-statistics}
taylor_album_summary <- taylor_album_songs %>% group_by(album_name)%>% summarize(
  mean_loudness = mean(loudness),
  mean_danceability = mean(danceability),
  mean_liveness = mean(liveness),
  mean_energy = mean(energy),
  mean_mode = round(mean(mode)),
  mean_speechiness = mean(speechiness),
  mean_acousticness = mean(acousticness),
  mean_instrumentalness = mean(instrumentalness),
  mean_valence = mean(valence),
  mean_tempo = mean(tempo)
) %>% inner_join(taylor_albums, by=c("album_name")) %>% relocate(album_release, .after=album_name)
```

Overall Metacritic scores and user scores are representative of the popularity of the albums because they are the "weighted average" of the albums' individual scores
from critics and the public respectively (Metacritic, 2023).

While the Metacritic score ranges from 0 to 100 (Metacritic, 2023), the user score has a different range of 0 to 10 which we noticed when exploring the "user reviews" section (Metacritic, n.d.).
We will aggregate these into one statistic, "Popularity", weighted by their respective ranges. 

Hence we use the following formula: Popularity = (metacritic_score+(user_score*10))/2

```{r creating-Popularity}
taylor_album_summary <- taylor_album_summary %>% mutate(Popularity = (metacritic_score+user_score*10)/2)
taylor_album_summary[, c(1,2,12)]
```


## 3. Visualisations
### a. What are the most significant features?

```{r boxplot}
taylor_long = taylor_album_songs %>% pivot_longer()
```

### b. Have the features we selected influenced Taylor Swift's popularity?
Exploratory plots: May or may not use, just to select

```{r}
points = lm(data=taylor_album_summary, album_release~Popularity)
ggplot(taylor_album_summary, aes(x=album_release, y=Popularity, color=album_name)) +
  geom_point(size=2) 
```

```{r}
plotting = taylor_album_summary %>% pivot_longer(cols =c(mean_liveness, mean_danceability, mean_energy, mean_acousticness, mean_instrumentalness, mean_valence), names_to="variable", values_to="value")
ggplot(plotting, aes(x=album_release, y=value, color = variable)) +
  geom_point(size=3) +
  geom_smooth(method="lm") +
  theme_classic()
```

```{r loudness-plot}
ggplot(taylor_album_summary, aes(x=album_release, y=mean_loudness)) +
  geom_point(size=3) +
  geom_smooth(method="lm") +
  theme_classic()
```

Valence dropped, songs became sadder. Instrumentalness dropped, songs became more vocally driven.
Acousticness increased sharply, songs involved lesser electronic sounds and sounded more raw.
Energy of the tracks have also reduced, further emphasising the mellow trend of her music. Though, it appears
that danceability has increased, meaning that the downbeats in her songs have become more pronounced,
creating a danceable vibe.
It seems that Taylor Swift aims to be more intimate with her audience while maintaining vibe and groove to make up for
the lack of energy. Her popularity has increased over the years also, signalling the yearn for such music.

### c. Which feature(s) has/have the greatest impact on Taylor Swift's songs?



## 4. Discussions
### a.

### b.

### c.


## 5. Teamwork



## 6. References
Harmon, J. (2023, October 16). Taylor Swift. GitHub. https://github.com/rfordatascience/tidytuesday/blob/master/data/2023/2023-10-17/readme.md  
Metacritic. (2023). How do you compute METASCORES? Retrieved November 7, 2024, from https://metacritichelp.zendesk.com/hc/en-us/articles/14478499933079-How-do-you-compute-METASCORES  
Metacritic. (n.d.). Taylor Swift by Taylor Swift. https://www.metacritic.com/music/taylor-swift/taylor-swift/user-reviews  